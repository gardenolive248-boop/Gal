<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Starseed Defender — Surprise Game</title>
<style>
  :root{
    --bg:#071023;
    --panel:#0e1624;
    --accent:#7ef9c9;
    --muted:#9fb0c8;
    --danger:#ff6b6b;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,var(--bg),#022);color:#e8f1ff}
  .wrap{display:flex;gap:18px;max-width:1100px;margin:22px auto;padding:18px;align-items:flex-start}
  .game{
    flex:1; min-width:320px; max-width:720px;
    background:radial-gradient(ellipse at 20% 10%, rgba(126,249,201,0.06), transparent 8%),
               radial-gradient(ellipse at 80% 90%, rgba(126,249,201,0.03), transparent 15%),
               linear-gradient(180deg,#021123 0%, #02061a 100%);
    border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6); position:relative;
  }
  canvas{display:block;width:100%;height:auto;border-radius:8px;background:transparent}
  .hud{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:8px}
  .panel{background:linear-gradient(180deg,var(--panel),#071018);padding:8px 10px;border-radius:10px;color:var(--muted);font-size:14px;min-width:64px;text-align:center}
  .panel.big{font-size:16px;padding:12px 14px}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:#0b2030;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:10px 12px;border-radius:8px;font-weight:600}
  button.primary{background:linear-gradient(90deg,var(--accent),#5fe3a1);color:#022}
  .rightCol{width:320px;display:flex;flex-direction:column;gap:12px}
  .card{background:linear-gradient(180deg,#071a2a,#04101a);padding:12px;border-radius:10px;color:var(--muted);box-shadow:inset 0 1px rgba(255,255,255,0.02)}
  .title{font-weight:700;color:var(--accent);font-size:18px;margin-bottom:6px}
  .small{font-size:13px;color:#a7bed6}
  .center{display:flex;align-items:center;justify-content:center}
  /* mobile virtual controls */
  .touch-controls{display:none;gap:8px;margin-top:8px}
  .touch-btn{width:64px;height:64px;border-radius:12px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;color:var(--muted);font-weight:700;user-select:none;touch-action:none}
  @media (max-width:880px){
    .wrap{padding:12px;gap:12px}
    .rightCol{width:100%}
    .wrap{flex-direction:column;align-items:stretch}
    .touch-controls{display:flex}
  }
  footer{opacity:0.7;font-size:12px;margin-top:10px;color:var(--muted)}
  .hint{color:#cfeee0;font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <div class="game">
    <canvas id="c"></canvas>
    <div class="hud">
      <div class="panel big">Score: <span id="score">0</span></div>
      <div class="controls">
        <div class="panel">Lives: <span id="lives">3</span></div>
        <div class="panel">Wave: <span id="wave">0</span></div>
        <div class="panel">High: <span id="high">0</span></div>
      </div>
    </div>

    <div class="touch-controls center" style="margin-top:12px">
      <div class="touch-btn" id="leftBtn">◀</div>
      <div class="touch-btn" id="shootBtn">●</div>
      <div class="touch-btn" id="rightBtn">▶</div>
    </div>

    <div style="margin-top:12px;display:flex;gap:8px;justify-content:center">
      <button id="startBtn" class="primary">Start / Restart</button>
      <button id="pauseBtn">Pause</button>
      <button id="mutebtn">Mute</button>
    </div>

    <footer class="center"><span class="hint">Use ← → and space to move & shoot. On mobile use the buttons above.</span></footer>
  </div>

  <div class="rightCol">
    <div class="card">
      <div class="title">How to play</div>
      <div class="small">
        Protect the starseeds at the bottom by shooting falling enemies. Enemies drop <strong>power-ups</strong> occasionally. Survive waves — score increases with combos and accuracy.
      </div>
      <div style="margin-top:8px" class="small">
        Controls: keyboard or on-screen buttons. Score saved locally.
      </div>
    </div>

    <div class="card">
      <div class="title">Power-ups</div>
      <div class="small">
        <ul>
          <li>Rapid Fire — shoot faster for a short time</li>
          <li>Shield — temporary invulnerability</li>
          <li>Bomb — clears nearby enemies</li>
        </ul>
      </div>
    </div>

    <div class="card">
      <div class="title">About</div>
      <div class="small">Generated by ChatGPT — tiny handcrafted game engine. Tweak variables in the JS section to change difficulty, speed, and visuals.</div>
    </div>
  </div>
</div>

<script>
/*
  Starseed Defender
  Single-file HTML game (canvas). Plays in-browser.
  Controls: Left/Right arrow or A/D to move. Space to shoot.
  Touch buttons provided for mobile.
*/

// === Setup canvas ===
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });
let W = 720, H = 960;
function resizeCanvas() {
  const ratio = window.devicePixelRatio || 1;
  const parentWidth = Math.min(window.innerWidth - 48, 720);
  W = parentWidth;
  H = Math.round(parentWidth * (4/3)); // 4:3-ish
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width = Math.round(W * ratio);
  canvas.height = Math.round(H * ratio);
  ctx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// === Game state ===
let score = 0, lives = 3, wave = 0, high = +localStorage.getItem('starseed_high') || 0;
document.getElementById('high').textContent = high;
let running = false, paused = false, muted = false;

// Entities
const player = {
  x: 0.5 * W,
  y: H - 80,
  w: 48,
  h: 20,
  speed: 360, // px/sec
  cooldown: 0,
  fireRate: 280, // ms between shots
  bullets: []
};
let enemies = [];
let pickups = [];
let particles = [];

// Timing
let last = performance.now();
let accum = 0;

// Utility
function rand(min,max){return Math.random()*(max-min)+min}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

// Basic rectangle collision
function coll(a,b){
  return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);
}

// === Audio (tiny beeps) ===
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx) audioCtx = new AudioCtx();
}
function beep(freq=440, dur=0.08, gain=0.08){
  if(muted) return;
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

// === Controls ===
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.key === ' '){ e.preventDefault(); } // avoid page scroll
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// Touch buttons
const leftBtn = document.getElementById('leftBtn'), rightBtn = document.getElementById('rightBtn'), shootBtn = document.getElementById('shootBtn');
let touchLeft=false, touchRight=false, touchShoot=false;
[leftBtn,rightBtn,shootBtn].forEach(btn=>{
  btn.addEventListener('touchstart', e=>{ e.preventDefault(); if(btn===leftBtn) touchLeft=true; if(btn===rightBtn) touchRight=true; if(btn===shootBtn) touchShoot=true; });
  btn.addEventListener('touchend', e=>{ e.preventDefault(); if(btn===leftBtn) touchLeft=false; if(btn===rightBtn) touchRight=false; if(btn===shootBtn) touchShoot=false; });
  btn.addEventListener('mousedown', e=>{ e.preventDefault(); if(btn===leftBtn) touchLeft=true; if(btn===rightBtn) touchRight=true; if(btn===shootBtn) touchShoot=true; });
  btn.addEventListener('mouseup', e=>{ e.preventDefault(); if(btn===leftBtn) touchLeft=false; if(btn===rightBtn) touchRight=false; if(btn===shootBtn) touchShoot=false; });
});

// UI buttons
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
});
document.getElementById('mutebtn').addEventListener('click', ()=>{
  muted = !muted;
  document.getElementById('mutebtn').textContent = muted ? 'Unmute' : 'Mute';
});

// === Game mechanics ===
function startGame(){
  score = 0; lives = 3; wave = 0; enemies=[]; pickups=[]; particles=[];
  player.x = W/2; player.cooldown = 0; player.fireRate = 280; player.bullets=[];
  running = true; paused=false;
  document.getElementById('pauseBtn').textContent = 'Pause';
  document.getElementById('score').textContent = score;
  document.getElementById('lives').textContent = lives;
  spawnWave();
  beep(880,0.08,0.06);
}

function spawnWave(){
  wave++;
  document.getElementById('wave').textContent = wave;
  // number and speed scale with wave
  const count = 4 + Math.floor(wave * 1.5);
  const pattern = Math.random() < 0.6 ? 'fall' : 'zig';
  for(let i=0;i<count;i++){
    const ex = rand(40, W-40);
    const ey = rand(-480, -40 - i*40);
    const speed = rand(60 + wave*6, 110 + wave*10);
    const t = { 
      x: ex, y: ey, w: 36, h: 28, speed, hp: 1 + Math.floor(wave/4),
      type: (Math.random() < Math.min(0.12, 0.04 + wave*0.01)) ? 'tank' : 'grunt',
      pattern
    };
    if(t.type === 'tank'){ t.w=48; t.h=36; t.hp=2 + Math.floor(wave/5); t.speed*=0.7; }
    enemies.push(t);
  }
}

// Power-ups drop with some probability
function maybeDropPickup(x,y){
  const r = Math.random();
  if(r < 0.08){
    pickups.push({x:x-12,y:y-12,w:24,h:24,kind: 'rapid',t:9}); // 9 seconds
  } else if(r < 0.14){
    pickups.push({x:x-12,y:y-12,w:24,h:24,kind:'shield',t:6});
  } else if(r < 0.18){
    pickups.push({x:x-12,y:y-12,w:24,h:24,kind:'bomb'});
  }
}

// bullets update
function fireBullet(x,y,vx,vy,from='player'){
  player.bullets.push({x,y,w:6,h:12,vx,vy,from});
  beep(1200,0.03,0.04);
}

// spawn explosion particles
function spawnParticles(x,y,cnt=14,color='#fff'){
  for(let i=0;i<cnt;i++){
    particles.push({
      x, y,
      vx: Math.cos(Math.random()*Math.PI*2) * rand(20,180),
      vy: Math.sin(Math.random()*Math.PI*2) * rand(20,180),
      life: rand(0.4,1.0),
      t:0, color
    });
  }
}

// === Main update loop ===
let shieldTimer = 0;
let rapidTimer = 0;
let bombCount = 0;
function update(dt){
  if(!running || paused) return;

  // player input
  const left = keys['arrowleft'] || keys['a'] || touchLeft;
  const right = keys['arrowright'] || keys['d'] || touchRight;
  const shooting = keys[' '] || keys['space'] || touchShoot;

  // move player
  if(left) player.x -= player.speed * dt;
  if(right) player.x += player.speed * dt;
  player.x = clamp(player.x, 20, W - 20);

  // shoot cooldown
  player.cooldown -= dt*1000;
  if((shooting || keys['k']) && player.cooldown <= 0){
    // single or double shot with rapid fire
    player.cooldown = player.fireRate;
    const bx = player.x;
    const by = player.y - 14;
    if(rapidTimer > 0){
      fireBullet(bx-10, by, 0, -480);
      fireBullet(bx+10, by, 0, -480);
    } else {
      fireBullet(bx, by, 0, -520);
    }
  }

  // update bullets
  for(let i = player.bullets.length-1; i>=0; i--){
    const b = player.bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    // remove if offscreen
    if(b.y < -40 || b.y > H+40 || b.x < -40 || b.x > W+40) player.bullets.splice(i,1);
  }

  // update enemies
  for(let i = enemies.length-1; i>=0; i--){
    const e = enemies[i];
    // movement patterns
    if(e.pattern === 'zig'){
      e.x += Math.sin((performance.now()/1000 + i)*2.1) * 28 * dt * (1 + wave*0.02);
    } else {
      // fall straight but with tiny flicker
      e.x += Math.sin((e.y + i*13)*0.02) * 10 * dt;
    }
    e.y += e.speed * dt;

    // if enemy passes bottom: hit player
    if(e.y > H + 30){
      enemies.splice(i,1);
      loseLife();
      continue;
    }

    // enemy hit by bullets
    for(let j = player.bullets.length-1; j>=0; j--){
      const b = player.bullets[j];
      if(coll({x:b.x-b.w/2,y:b.y-b.h/2,w:b.w,h:b.h}, {x:e.x-e.w/2,y:e.y-e.h/2,w:e.w,h:e.h})){
        player.bullets.splice(j,1);
        e.hp--;
        score += 10;
        spawnParticles(e.x, e.y, 8, e.type==='tank' ? '#ffcc66' : '#7ef9c9');
        if(e.hp <= 0){
          // destroyed
          enemies.splice(i,1);
          score += e.type==='tank' ? 40 : 20;
          maybeDropPickup(e.x, e.y);
          beep(520,0.06,0.08);
        } else {
          beep(360,0.03,0.06);
        }
        break;
      }
    }
  }

  // pickups falling
  for(let i = pickups.length-1; i>=0; i--){
    const p = pickups[i];
    p.y += 120 * dt;
    if(p.y > H + 24){ pickups.splice(i,1); continue; }
    // collision with player
    const px = p.x, py = p.y, pw = p.w, ph = p.h;
    if(coll({x:px,y:py,w:pw,h:ph}, {x:player.x-30,y:player.y-10,w:60,h:30})){
      // activate pickup
      if(p.kind === 'rapid'){ rapidTimer = Math.max(rapidTimer, p.t || 8); player.fireRate = 120; }
      if(p.kind === 'shield'){ shieldTimer = Math.max(shieldTimer, p.t || 6); }
      if(p.kind === 'bomb'){ bombCount++; }
      pickups.splice(i,1);
      beep(1400,0.06,0.06);
      score += 30;
    }
  }

  // particles
  for(let i = particles.length-1; i>=0; i--){
    const part = particles[i];
    part.t += dt;
    part.x += part.vx * dt;
    part.y += part.vy * dt;
    part.vx *= 0.99; part.vy *= 0.99;
    if(part.t > part.life) particles.splice(i,1);
  }

  // timers
  if(shieldTimer > 0) shieldTimer = Math.max(0, shieldTimer - dt);
  if(rapidTimer > 0){ rapidTimer = Math.max(0, rapidTimer - dt); if(rapidTimer === 0) player.fireRate = 280; }

  // wave clear -> next wave
  if(enemies.length === 0){
    // short gap then spawn new wave
    setTimeout(()=>{ if(running) spawnWave(); }, 600);
  }

  // update UI
  document.getElementById('score').textContent = score;
  document.getElementById('lives').textContent = lives;
  if(score > high){ high = score; localStorage.setItem('starseed_high', high); document.getElementById('high').textContent = high; }
}

// lose life
function loseLife(){
  if(shieldTimer > 0){ shieldTimer = 0; return; } // shield absorbs
  lives--;
  spawnParticles(player.x, player.y, 18, '#ff6b6b');
  beep(160,0.12,0.12);
  if(lives <= 0){
    running = false;
    // game over
    setTimeout(()=>{ showGameOver(); }, 200);
  }
}

// Bomb use
function useBomb(){
  if(bombCount <= 0) return;
  bombCount--;
  // clear enemies in radius
  const radius = 220;
  for(let i = enemies.length-1; i>=0; i--){
    const e = enemies[i];
    const dx = e.x - player.x, dy = e.y - player.y;
    if(dx*dx + dy*dy < radius*radius){
      spawnParticles(e.x, e.y, 18, '#fff2aa');
      score += (e.type === 'tank' ? 70 : 30);
      enemies.splice(i,1);
    }
  }
  beep(260,0.16,0.16);
}

// show game over overlay
function showGameOver(){
  // simple alert-like overlay
  const overlay = document.createElement('div');
  overlay.style.position = 'absolute';
  overlay.style.left = '0';
  overlay.style.top = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'linear-gradient(180deg, rgba(2,6,13,0.6), rgba(2,6,13,0.9))';
  overlay.style.backdropFilter = 'blur(6px)';
  overlay.style.zIndex = '40';
  overlay.innerHTML = `
    <div style="background:#061426;padding:24px;border-radius:12px;text-align:center;box-shadow:0 8px 30px rgba(0,0,0,0.6);min-width:260px">
      <div style="font-size:20px;color:var(--accent);font-weight:700;margin-bottom:6px">GAME OVER</div>
      <div style="color:#d4eaf0;margin-bottom:10px">Score: <strong>${score}</strong></div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="replayBtn" class="primary">Play Again</button>
        <button id="dismissBtn">Close</button>
      </div>
    </div>
  `;
  document.querySelector('.game').appendChild(overlay);
  document.getElementById('replayBtn').addEventListener('click', ()=>{ overlay.remove(); startGame(); });
  document.getElementById('dismissBtn').addEventListener('click', ()=>{ overlay.remove(); });
}

// === Render ===
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // background stars
  drawBackground();

  // draw pickups
  for(const p of pickups){
    ctx.save();
    ctx.translate(p.x + p.w/2, p.y + p.h/2);
    ctx.rotate((performance.now()/1000) % (Math.PI*2));
    ctx.fillStyle = (p.kind==='rapid'?'#7ef9c9': p.kind==='shield' ? '#66b3ff' : '#ffd166');
    roundRect(ctx, -p.w/2, -p.h/2, p.w, p.h, 6);
    ctx.fill();
    ctx.restore();
  }

  // draw player (a little ship)
  ctx.save();
  ctx.translate(player.x, player.y);
  // shield
  if(shieldTimer > 0){
    const a = 0.25 + 0.75 * Math.sin(performance.now()/80/10);
    ctx.beginPath(); ctx.arc(0,0,48+a*6,0,Math.PI*2); ctx.fillStyle = 'rgba(102,179,255,0.08)'; ctx.fill();
    ctx.strokeStyle = 'rgba(102,179,255,0.18)'; ctx.lineWidth = 2; ctx.stroke();
  }
  // ship body
  ctx.beginPath();
  ctx.moveTo(0,-24);
  ctx.lineTo(14,12);
  ctx.lineTo(6,8);
  ctx.lineTo(-6,8);
  ctx.lineTo(-14,12);
  ctx.closePath();
  ctx.fillStyle = '#bfffe5';
  ctx.fill();
  ctx.strokeStyle = '#59d9a2'; ctx.lineWidth = 1.2; ctx.stroke();
  ctx.restore();

  // bullets
  ctx.fillStyle = '#c8ffe8';
  for(const b of player.bullets){
    ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h);
  }

  // enemies
  for(const e of enemies){
    ctx.save();
    ctx.translate(e.x, e.y);
    // hull
    const grad = ctx.createLinearGradient(-e.w/2,-e.h/2,e.w/2,e.h/2);
    grad.addColorStop(0, e.type==='tank' ? '#ffb07c' : '#7ef9c9');
    grad.addColorStop(1, '#21364a');
    roundRect(ctx, -e.w/2, -e.h/2, e.w, e.h, 6);
    ctx.fillStyle = grad; ctx.fill();
    // eyes or core
    ctx.fillStyle = '#041829';
    ctx.fillRect(-6, -6, 12, 8);
    ctx.restore();
  }

  // particles
  for(const p of particles){
    const alpha = 1 - p.t / p.life;
    ctx.fillStyle = p.color || '#fff';
    ctx.globalAlpha = alpha;
    ctx.fillRect(p.x-1.5, p.y-1.5, 3, 3);
    ctx.globalAlpha = 1;
  }

  // HUD overlays
  ctx.fillStyle = '#a7c4d9';
  ctx.font = '13px system-ui,Arial';
  ctx.textAlign = 'left';
  ctx.fillText('Bombs: ' + bombCount, 12, 18);
  if(rapidTimer > 0) ctx.fillText('Rapid: ' + Math.ceil(rapidTimer) + 's', 12, 36);
  if(shieldTimer > 0) ctx.fillText('Shield: ' + Math.ceil(shieldTimer) + 's', 12, 54);

  // subtle vignette
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  const vg = ctx.createLinearGradient(0,0,0,H);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(0,0,0,0.24)');
  ctx.fillStyle = vg;
  ctx.fillRect(0,0,W,H);
  ctx.restore();
}

// background stars and small parallax
const starField = Array.from({length: 80}, ()=>({x:rand(0,W), y:rand(0,H), s:rand(0.5,1.6), tw: rand(0.2,0.8)}));
function drawBackground(){
  // fade to deep space
  ctx.fillStyle = 'rgba(2,10,20,0.86)';
  ctx.fillRect(0,0,W,H);

  for(const s of starField){
    s.y += 8 * s.s * 0.02;
    s.x += Math.sin((performance.now()/1000)*0.2 + s.tw) * 0.2;
    if(s.y > H) { s.y = -4; s.x = rand(0,W); }
    ctx.fillStyle = 'rgba(255,255,255,' + (0.2 + 0.8 * Math.abs(Math.sin(performance.now()/1000*2 + s.tw))) + ')';
    ctx.fillRect(s.x, s.y, 1*s.s, 1*s.s);
  }
}

// helper: rounded rect
function roundRect(ctx,x,y,w,h,r){
  if(w<0) { x+=w; w=-w; }
  if(h<0) { y+=h; h=-h; }
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

// main loop
function loop(now){
  const dt = Math.min((now - last) / 1000, 0.04);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if(e.key === 'b') useBomb(); // press 'b' to use bomb
  if(e.key === 'r') startGame();
});

// small tip: make canvas responsive on orientation change
window.addEventListener('orientationchange', ()=> setTimeout(resizeCanvas,200));

// autoplay start for quick demo (but do not auto-start audio)
setTimeout(()=>{ if(!running) startGame(); }, 500);

// expose a few vars so curious devs can tweak from console
window.starseed = {
  player, enemies, pickups, particles, startGame, useBomb, getState: ()=>({score,lives,wave,high})
};
</script>
</body>
</html>
